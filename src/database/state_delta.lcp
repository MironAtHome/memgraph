#>cpp
#pragma once

#include "communication/bolt/v1/decoder/decoder.hpp"
#include "communication/bolt/v1/encoder/primitive_encoder.hpp"
#include "durability/hashed_file_reader.hpp"
#include "durability/hashed_file_writer.hpp"
#include "storage/address_types.hpp"
#include "storage/gid.hpp"
#include "storage/property_value.hpp"
cpp<#

(lcp:namespace database)

(lcp:capnp-namespace "database")

(lcp:capnp-type-conversion "tx::TransactionId" "UInt64")
(lcp:capnp-type-conversion "gid::Gid" "UInt64")
(lcp:capnp-type-conversion "storage::Label" "Storage.Common")
(lcp:capnp-type-conversion "storage::EdgeType" "Storage.Common")
(lcp:capnp-type-conversion "storage::Property" "Storage.Common")
(lcp:capnp-type-conversion "storage::EdgeAddress" "Storage.Address")
(lcp:capnp-type-conversion "storage::VertexAddress" "Storage.Address")

(lcp:define-struct state-delta ()
  (
   ;; Members valid for every delta.
   (type "Type" :capnp-init nil
         :capnp-save (lcp:capnp-save-enum "capnp::StateDelta::Type" "Type")
         :capnp-load (lcp:capnp-load-enum "capnp::StateDelta::Type" "Type"))
   (transaction-id "tx::TransactionId")
   ;; Members valid only for some deltas, see StateDelta::Type comments above.
   ;; TODO: when preparing the WAL for distributed, most likely remove Gids and
   ;; only keep addresses.
   (vertex-id "gid::Gid")
   (edge-id "gid::Gid")
   (cypher-id :int64_t)
   (edge-address "storage::EdgeAddress")
   (vertex-from-id "gid::Gid")
   (vertex-from-address "storage::VertexAddress")
   (vertex-to-id "gid::Gid")
   (vertex-to-address "storage::VertexAddress")
   (edge-type "storage::EdgeType")
   (edge-type-name "std::string")
   (property "storage::Property")
   (property-name "std::string")
   (value "PropertyValue" :initval "PropertyValue::Null"
          :save-fun #>cpp utils::SaveTypedValue(ar, value); cpp<#
          :load-fun
          #>cpp
          query::TypedValue tv;
          utils::LoadTypedValue(ar, tv);
          value = tv;
          cpp<#
          :capnp-type "Dis.TypedValue"
          :capnp-save
          (lambda (builder member)
            #>cpp
            utils::SaveCapnpTypedValue(${member}, &${builder});
            cpp<#)
          :capnp-load
          (lambda (reader member)
            #>cpp
            query::TypedValue tv;
            utils::LoadCapnpTypedValue(${reader}, &tv);
            ${member} = tv;
            cpp<#))
   (label "storage::Label")
   (label-name "std::string")
   (check-empty :bool))
  (:documentation
   "Describes single change to the database state. Used for durability (WAL) and
state communication over network in HA and for distributed remote storage
changes.

Labels, Properties and EdgeTypes are stored both as values (integers) and
strings (their names). The values are used when applying deltas in a running
database. Names are used when recovering the database as it's not guaranteed
that after recovery the old name<->value mapping will be preserved.

TODO: ensure the mapping is preserved after recovery and don't save strings
in StateDeltas.")
  (:public
   (lcp:define-enum type
       (transaction-begin
        transaction-commit
        transaction-abort
        create-vertex ;; vertex_id
        create-edge   ;; edge_id, from_vertex_id, to_vertex_id, edge_type, edge_type_name
        add-out-edge  ;; vertex_id, edge_address, vertex_to_address, edge_type
        remove-out-edge ;; vertex_id, edge_address
        add-in-edge     ;; vertex_id, edge_address, vertex_from_address, edge_type
        remove-in-edge  ;; vertex_id, edge_address
        set-property-vertex ;; vertex_id, property, property_name, property_value
        set-property-edge   ;; edge_id, property, property_name, property_value
        ;; remove property is done by setting a PropertyValue::Null
        add-label     ;; vertex_id, label, label_name
        remove-label  ;; vertex_id, label, label_name
        remove-vertex ;; vertex_id, check_empty
        remove-edge   ;; edge_id
        build-index   ;; label, label_name, property, property_name
        )
     (:documentation
      "Defines StateDelta type. For each type the comment indicates which values
need to be stored. All deltas have the transaction_id member, so that's
omitted in the comment.")
     (:serialize))
     #>cpp
     StateDelta() = default;
     StateDelta(const enum Type &type, tx::TransactionId tx_id)
         : type(type), transaction_id(tx_id) {}

     /** Attempts to decode a StateDelta from the given decoder. Returns the
      * decoded value if successful, otherwise returns nullopt. */
     static std::experimental::optional<StateDelta> Decode(
         HashedFileReader &reader,
         communication::bolt::Decoder<HashedFileReader> &decoder);

     /** Encodes the delta using primitive encoder, and writes out the new hash
      * with delta to the writer */
     void Encode(
         HashedFileWriter &writer,
         communication::bolt::PrimitiveEncoder<HashedFileWriter> &encoder) const;

     static StateDelta TxBegin(tx::TransactionId tx_id);
     static StateDelta TxCommit(tx::TransactionId tx_id);
     static StateDelta TxAbort(tx::TransactionId tx_id);
     static StateDelta CreateVertex(tx::TransactionId tx_id,
                                    gid::Gid vertex_id,
                                    int64_t cypher_id);
     static StateDelta CreateEdge(tx::TransactionId tx_id, gid::Gid edge_id,
                                  int64_t cypher_id,
                                  gid::Gid vertex_from_id,
                                  gid::Gid vertex_to_id,
                                  storage::EdgeType edge_type,
                                  const std::string &edge_type_name);
     static StateDelta AddOutEdge(tx::TransactionId tx_id, gid::Gid vertex_id,
                                  storage::VertexAddress vertex_to_address,
                                  storage::EdgeAddress edge_address,
                                  storage::EdgeType edge_type);
     static StateDelta RemoveOutEdge(tx::TransactionId tx_id,
                                     gid::Gid vertex_id,
                                     storage::EdgeAddress edge_address);
     static StateDelta AddInEdge(tx::TransactionId tx_id, gid::Gid vertex_id,
                                 storage::VertexAddress vertex_from_address,
                                 storage::EdgeAddress edge_address,
                                 storage::EdgeType edge_type);
     static StateDelta RemoveInEdge(tx::TransactionId tx_id, gid::Gid vertex_id,
                                    storage::EdgeAddress edge_address);
     static StateDelta PropsSetVertex(tx::TransactionId tx_id,
                                      gid::Gid vertex_id,
                                      storage::Property property,
                                      const std::string &property_name,
                                      const PropertyValue &value);
     static StateDelta PropsSetEdge(tx::TransactionId tx_id, gid::Gid edge_id,
                                    storage::Property property,
                                    const std::string &property_name,
                                    const PropertyValue &value);
     static StateDelta AddLabel(tx::TransactionId tx_id, gid::Gid vertex_id,
                                storage::Label label,
                                const std::string &label_name);
     static StateDelta RemoveLabel(tx::TransactionId tx_id, gid::Gid vertex_id,
                                   storage::Label label,
                                   const std::string &label_name);
     static StateDelta RemoveVertex(tx::TransactionId tx_id, gid::Gid vertex_id,
                                    bool check_empty);
     static StateDelta RemoveEdge(tx::TransactionId tx_id, gid::Gid edge_id);
     static StateDelta BuildIndex(tx::TransactionId tx_id, storage::Label label,
                                  const std::string &label_name,
                                  storage::Property property,
                                  const std::string &property_name);

     /// Applies CRUD delta to database accessor. Fails on other types of deltas
     void Apply(GraphDbAccessor &dba) const;
     cpp<#)
  (:serialize))

(lcp:pop-namespace) ;; database
